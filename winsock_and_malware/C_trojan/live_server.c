#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>

#pragma comment(lib, "Ws2_32.lib")

#define BUFLEN 2048
#define PORT 27015
#define ADDRESS "127.0.0.1" // aka "localhost"

char* execute_command(char* command);
char* cd_path(char* path);
int main(int argc, char** argv)
{
    // if (argc != 2){
    //     printf("usage: %s <server-IP>\n", argv[0]);
    //     return 1;
    // }
    printf("Hello, world!\n");

    int res, sendRes;

    // INITIALIZATION ===========================
    WSADATA wsaData; // configuration data
    res = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (res)
    {
        printf("Startup failed: %d\n", res);
        return 1;
    }
    // ==========================================

    // SETUP SERVER =============================

    // construct socket
    SOCKET listener;
    listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (listener == INVALID_SOCKET)
    {
        printf("Error with construction: %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // bind to address
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    // address.sin_addr.s_addr = inet_addr(argv[1]);
    address.sin_addr.s_addr = inet_addr("0.0.0.0");
    address.sin_port = htons(PORT);
    res = bind(listener, (struct sockaddr *)&address, sizeof(address));
    if (res == SOCKET_ERROR)
    {
        printf("Bind failed: %d\n", WSAGetLastError());
        closesocket(listener);
        WSACleanup();
        return 1;
    }

    // set as a listener
    res = listen(listener, SOMAXCONN);
    if (res == SOCKET_ERROR)
    {
        printf("Listen failed: %d\n", WSAGetLastError());
        closesocket(listener);
        WSACleanup();
        return 1;
    }
    // ==========================================

    printf("Accepting on %s:%d\n", "0.0.0.0", PORT);

    // HANDLE A CLIENT ==========================

    // accept client socket
    SOCKET client;
    struct sockaddr_in clientAddr;
    int clientAddrlen;
    client = accept(listener, NULL, NULL);
    if (client == INVALID_SOCKET)
    {
        printf("Could not accept: %d\n", WSAGetLastError());
        closesocket(listener);
        WSACleanup();
        return 1;
    }

    // get client information
    getpeername(client, (struct sockaddr *)&clientAddr, &clientAddrlen);
    printf("Client connected at %s:%d\n", inet_ntoa(address.sin_addr), ntohs(address.sin_port));

    // send welcome message
    char *welcome = "Welcome to the server :)";
    sendRes = send(client, welcome, strlen(welcome), 0);
    if (sendRes != strlen(welcome))
    {
        printf("Error sending: %d\n", WSAGetLastError());
        shutdown(client, SD_BOTH);
        closesocket(client);
    }

    // receive messages
    char recvbuf[BUFLEN];
    // char* sendBuf = (char*)malloc(2048);
    char* sendBuf;
    do
    {
        res = recv(client, recvbuf, BUFLEN, 0);
        if (res > 0)
        {
            recvbuf[res] = '\0';
            // printf("Message received (%d): %s\n", res, recvbuf);
            printf("Command (len %d)>  %s\n", res, recvbuf);

            if (!memcmp(recvbuf, "/quit", 5 * sizeof(char)))
            {
                // received quit command
                printf("Closing connection.\n");
                break;
            }
            sendBuf = execute_command(recvbuf);
            printf("%s", sendBuf);
            // echo message 
            //sendRes = send(client, recvbuf, res, 0);
            sendRes = send(client, sendBuf, 1024, 0);
            // if (sendRes != res)
            // {
            //     printf("Error sending: %d\n", WSAGetLastError());
            //     shutdown(client, SD_BOTH);
            //     closesocket(client);
            //     break;
            // }
        }
        else if (!res)
        {
            // client disconnected
            printf("Closing connection.\n");
            break;
        }
        else
        {
            printf("Receive failed: %d\n", WSAGetLastError());
            break;
        }
    } while (res > 0);

    // shutdown client
    res = shutdown(client, SD_BOTH);
    if (res == SOCKET_ERROR)
    {
        printf("Client shutdown failed: %d\n", WSAGetLastError());
    }
    closesocket(client);

    // ==========================================

    // CLEANUP ==================================
    // shut down server socket
    closesocket(listener);

    // cleanup WSA
    res = WSACleanup();
    if (res)
    {
        printf("Cleanup failed: %d\n", res);
        return 1;
    }
    // ==========================================

    printf("Shutting down.\nGood night.\n");

    return 0;
}


char* execute_command(char* command)
{
    FILE *fp;
    char path[100];
    char* path_rt = (char*)malloc(2048);
    fp = popen(command, "r");
    if (fp == NULL) {
        printf("Failed to run command\n" );
        exit(1);
    }
    /* Read the output a line at a time - output it. */
    while (fgets(path, sizeof(path), fp) != NULL) {
        // printf("%s",path);
        // strcat(pathh,"\n");
        strcat(path_rt,path);
    } 
    // printf(pathh);
    char * token = strtok(command, " ");
    if (strcmp(token,"cd")==0){
        token = strtok(NULL, " ");
        char* to = strtok(token, "\\");
        while( to != NULL ) {
            if(strcmp(cd_path(token),"Path Failed")==0){
                return "Path Failed";
            }
            to = strtok(NULL, "\\");
        }
    }
    pclose(fp);
    return path_rt;
}

char* cd_path(char* path){

    char *buffer = (char*)malloc(1024);
    if(_chdir(path)==-1){
        return "Path Failed";
    }
    _getcwd(buffer,1024);
    return buffer;
}

//gcc server.c -o server -lws2_32